<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Invalid calendar dates</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for clock-invalid {clock}"><tr><td>clock-invalid {clock}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Invalid calendar dates</h2>

<h3>Description</h3>

<p>This family of functions is for working with <em>invalid</em> calendar dates.
These represent dates that don't exist, such as
<code>year_month_day(2019, 02, 31)</code>.
</p>
<p>Invalid dates are allowed in clock, provided that they are eventually
resolved by using <code>invalid_resolve()</code> or by manually resolving them through
arithmetic or setter functions.
</p>


<h3>Usage</h3>

<pre>
invalid_detect(x)

invalid_any(x)

invalid_count(x)

invalid_resolve(x, ..., invalid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p><code style="white-space: pre;">[calendar]</code>
</p>
<p>A calendar vector.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr valign="top"><td><code>invalid</code></td>
<td>
<p><code style="white-space: pre;">[character(1) / NULL]</code>
</p>
<p>One of the following invalid date resolution strategies:
</p>

<ul>
<li> <p><code>"previous"</code>: The previous valid instant in time.
</p>
</li>
<li> <p><code>"previous-day"</code>: The previous valid day in time, keeping the time of
day.
</p>
</li>
<li> <p><code>"next"</code>: The next valid instant in time.
</p>
</li>
<li> <p><code>"next-day"</code>: The next valid day in time, keeping the time of day.
</p>
</li>
<li> <p><code>"overflow"</code>: Overflow by the number of days that the input is invalid
by. Time of day is dropped.
</p>
</li>
<li> <p><code>"overflow-day"</code>: Overflow by the number of days that the input is
invalid by. Time of day is kept.
</p>
</li>
<li> <p><code>"NA"</code>: Replace invalid dates with <code>NA</code>.
</p>
</li>
<li> <p><code>"error"</code>: Error on invalid dates.
</p>
</li></ul>

<p>Using either <code>"previous"</code> or <code>"next"</code> is generally recommended, as these
two strategies maintain the <em>relative ordering</em> between elements of the
input.
</p>
<p>If <code>NULL</code>, defaults to <code>"error"</code>.
</p>
<p>If <code>getOption("clock.strict")</code> is <code>TRUE</code>, <code>invalid</code> must be supplied and
cannot be <code>NULL</code>. This is a convenient way to make production code robust
to invalid dates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invalid dates must be resolved before converting them to a time point.
</p>
<p>It is recommended to use <code>"previous"</code> or <code>"next"</code> for resolving invalid
dates, as these ensure that <em>relative ordering</em> among <code>x</code> is maintained.
This is a often a very important property to maintain when doing time series
data analysis. See the examples for more information.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>invalid_detect()</code>: Returns a logical vector detecting invalid dates.
</p>
</li>
<li> <p><code>invalid_any()</code>: Returns <code>TRUE</code> if any invalid dates are detected.
</p>
</li>
<li> <p><code>invalid_count()</code>: Returns a single integer containing the number of
invalid dates.
</p>
</li>
<li> <p><code>invalid_resolve()</code>: Returns <code>x</code> with invalid dates resolved using the
<code>invalid</code> strategy.
</p>
</li></ul>



<h3>Examples</h3>

<pre>
# Invalid date
x &lt;- year_month_day(2019, 04, 30:31, c(3, 2), 30, 00)
x

invalid_detect(x)

# Previous valid moment in time
x_previous &lt;- invalid_resolve(x, invalid = "previous")
x_previous

# Previous valid day, retaining time of day
x_previous_day &lt;- invalid_resolve(x, invalid = "previous-day")
x_previous_day

# Note that `"previous"` retains the relative ordering in `x`
x[1] &lt; x[2]
x_previous[1] &lt; x_previous[2]

# But `"previous-day"` here does not!
x_previous_day[1] &lt; x_previous_day[2]

y &lt;- year_quarter_day(2019, 1, 90:92)
y

# Overflow rolls forward by the number of days between `y` and the previous
# valid date
invalid_resolve(y, invalid = "overflow")
</pre>

<hr /><div style="text-align: center;">[Package <em>clock</em> version 0.3.0 <a href="00Index.html">Index</a>]</div>
</body></html>
